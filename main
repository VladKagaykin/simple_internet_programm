#include <iostream>
#include <vector>
#include <map>
#include <thread>
#include <boost/asio.hpp>
#include <boost/bind/bind.hpp>

using namespace boost::asio;
using ip::tcp;
using namespace std;

std::string get_external_ip() {
    try {
        io_service io_service;
        tcp::resolver resolver(io_service);
        tcp::resolver::query query("ifconfig.me", "80");
        tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);

        tcp::socket socket(io_service);
        connect(socket, endpoint_iterator);

        std::string request = "GET /ip HTTP/1.1\r\n"
                              "Host: ifconfig.me\r\n"
                              "Connection: close\r\n\r\n";
        write(socket, buffer(request));

        boost::asio::streambuf response; // Явное указание пространства имен
        read_until(socket, response, "\r\n\r\n");
        read_until(socket, response, "\r\n");

        std::stringstream ss;
        ss << &response;
        std::string full_response = ss.str();

        size_t pos = full_response.find("\r\n\r\n");
        if(pos != std::string::npos) {
            std::string ip_address = full_response.substr(pos+4);
            return ip_address;
        }
    } catch (std::exception& e) {
        std::cerr << "Ошибка: " << e.what() << std::endl;
    }
    return "Не удалось получить внешний IP";
}

std::string host(){
    std::string hostname = boost::asio::ip::host_name();
    return hostname;
}

std::string ipv4() {
    try {
        io_service io_service;
        tcp::resolver resolver(io_service);
        auto endpoints = resolver.resolve(host(), "");

        for (auto it = endpoints; it != tcp::resolver::iterator(); ++it) {
            const auto addr = it->endpoint().address();
            if (addr.is_v4()) {
                return addr.to_string();
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Ошибка получения IPv4: " << e.what() << std::endl;
    }
    return "";
}

std::string ipv6() {
    try {
        io_service io_service;
        tcp::resolver resolver(io_service);
        auto endpoints = resolver.resolve(host(), "");

        for (auto it = endpoints; it != tcp::resolver::iterator(); ++it) {
            const auto addr = it->endpoint().address();
            if (addr.is_v6()) {
                return addr.to_string();
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Ошибка получения IPv6: " << e.what() << std::endl;
    }
    return "";
}

int ip() {
    try {
        std::cout << "Имя хоста: " << host() << std::endl;

        std::string v4 = ipv4();
        std::string v6 = ipv6();

        std::cout << "Внутренние IP-адреса:\n";
        if (!v4.empty()) std::cout << "IPv4: " << v4 << std::endl;
        if (!v6.empty()) std::cout << "IPv6: " << v6 << std::endl;

        std::cout << "Ваш внешний IP-адрес: " << get_external_ip() << std::endl;

    } catch (const std::exception& ex) {
        std::cerr << "Исключение: " << ex.what() << std::endl;
        return 1;
    }
    return 0;
}

void scan_local_network() {
    try {
        io_service io_service;
        std::vector<std::string> local_ips;
        std::string hostname = host();
        tcp::resolver resolver(io_service);
        tcp::resolver::query query(hostname, "");
        tcp::resolver::iterator endpoints = resolver.resolve(query);

        for (; endpoints != tcp::resolver::iterator(); ++endpoints) {
            auto addr = endpoints->endpoint().address();
            if (addr.is_v4()) {
                local_ips.push_back(addr.to_string());
            }
        }

        if (local_ips.empty()) return;

        std::string base_ip = local_ips[0].substr(0, local_ips[0].rfind('.') + 1);
        std::cout << "\nСканирование локальной сети (" << base_ip << "X):\n";

        for (int i = 1; i < 255; ++i) {
            std::string target_ip = base_ip + std::to_string(i);
            tcp::endpoint ep(ip::make_address_v4(target_ip), 80);

            tcp::socket socket(io_service);
            boost::asio::steady_timer timer(io_service); // Исправленный таймер
            bool connected = false;

            socket.async_connect(ep, [&](auto) { connected = true; });
            timer.expires_from_now(boost::asio::chrono::milliseconds(500)); // Исправление времени
            timer.async_wait([&](auto) { socket.close(); });

            io_service.reset();
            io_service.run_one();

            if (connected) {
                try {
                    tcp::resolver dns_resolver(io_service);
                    tcp::resolver::query dns_query(tcp::v4(), target_ip, "");
                    auto it = dns_resolver.resolve(dns_query);
                    if(it != tcp::resolver::iterator()) {
                        std::string hostname = it->host_name();
                        if(hostname != target_ip) {
                            std::cout << target_ip << " - " << hostname << '\n';
                        } else {
                            std::cout << target_ip << " - имя совпадает с IP\n";
                        }
                    }
                } catch (boost::system::system_error& e) {
                    std::cout << target_ip << " - ошибка DNS: " << e.what() << '\n';
                }
            }
        }
    } catch (...) {}
}

class VPNServer {
    io_service& io_service_;
    tcp::acceptor acceptor_;
    std::map<std::string, tcp::socket> clients_;

public:
    VPNServer(io_service& service, short port) 
        : io_service_(service), 
          acceptor_(service, tcp::endpoint(tcp::v4(), port)) 
    {
        start_accept();
    }

    void start_accept() {
        auto socket = std::make_shared<tcp::socket>(io_service_);
        acceptor_.async_accept(*socket, [this, socket](const boost::system::error_code& ec) {
            if (!ec) {
                auto& sock_ref = *socket;
                clients_.emplace("client", std::move(sock_ref)); // Исправление для работы с map
            }
            start_accept();
        });
    }
};

int help(){
    std::cout << "help - это меню(удивительно)" << std::endl;
    std::cout << "exit - выйти" << std::endl;
    std::cout << "host - имя хоста(локальное)" << std::endl;
    std::cout << "local - ищет все ip в локальной сети и пишет их имена(если есть)" << std::endl;
    std::cout << "ip - выводит конкретные сведенья об ip" << std::endl;
    std::cout << "external_ip - выводит только внешний ipv4" << std::endl;
    std::cout << "ipv4 - выводит только ipv4" << std::endl;
    std::cout << "ipv6 - выводит только ipv6" << std::endl;
    return 0;
}

int switch_function(){
    std::string user;
    while(user != "exit"){
        std::cin >> user;

        if(user == "host"){
            std::cout << host() << std::endl;
        }
        else if(user == "local"){
            scan_local_network();
        }
        else if(user == "ip"){
            ip();
        }
        else if(user == "external_ip"){
            std::cout << get_external_ip() << std::endl;
        }
        else if(user == "ipv4"){
            std::cout << ipv4() << std::endl;
        }
        else if(user == "ipv6"){
            std::cout << ipv6() << std::endl;
        }
        else if(user == "help"){
            help();
        }
        else if(user == "exit"){}
        else{
            std::cout << "Введена некорректная комманда, введите help чтобы узнать список комманд" << std::endl;
        }
    }
    return 0;
}

int main() {
    switch_function();
    return 0;
}
